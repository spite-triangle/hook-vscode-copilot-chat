# 补全

## NES 补全

- 文件： `src\extension\xtab\node\xtabProvider.ts`
- 类：`XtabProvider`
- 修改: 构建新的 `message` 数据结构

```ts
private async *doGetNextEditWithSelection(
    request: StatelessNextEditRequest,
    selection: Range | null,
    delaySession: DelaySession,
    parentTracer: ILogger,
    logContext: InlineEditRequestLogContext,
    cancellationToken: CancellationToken,
    telemetryBuilder: StatelessNextEditTelemetryBuilder,
    retryState: RetryState.t,
): EditStreaming {
        /* ... */

        const userPrompt = getUserPrompt(promptPieces);

        const responseFormat = xtabPromptOptions.ResponseFormat.fromPromptingStrategy(promptOptions.promptingStrategy);

        const prediction = this.getPredictedOutput(activeDocument, editWindowLines, responseFormat);

        const toTextParts = (message: string): Raw.ChatCompletionContentPart[] => {
            return [{
                type: Raw.ChatCompletionContentPartKind.Text,
                text: message
            }]
        };

        const messages: Raw.ChatMessage[] = [
            {
                role: Raw.ChatRole.System,
                content: toTextParts(this.pickSystemPrompt(promptOptions.promptingStrategy))
            },
            {
                role: Raw.ChatRole.User, content: toTextParts(userPrompt + `current language is ${activeDocument.languageId}`)
            }
        ]

        if (typeof prediction?.content === "string" && prediction.content.length > 0) {
            messages.push(
                {
                    role: Raw.ChatRole.Assistant,
                    content: toTextParts(prediction.content)
                }
            )
            messages.push(
                {
                    role: Raw.ChatRole.User,
                content: toTextParts(`
对答案内容进行优化修正
1. 修正语法、语义错误，使答案更加符合 area_around_code_to_edit 的语境逻辑
2. 无需修改，则直接返回原始答案
3. **答案中未被修改的部分，应保持原样输出, 不要删除**。例如
    输入
    \`\`\`
    <|area_around_code_to_edit|>
        /*something block*/
    class A{
        /*something block*/
    <|code_to_edit|>
    };                  // pos-1
    /*something block*/
    function B(){      // pos-2
        /*something block*/   // pos-3
    <|/code_to_edit|>
        /*something block*/
    };
    <|/area_around_code_to_edit|>
    \`\`\`
    得到答案
    \`\`\`
    };                  // pos-1
    /*modify block*/
    function B(){      // pos-2
        /*something block*/   // pos-3
    \`\`\`
    修正后输出答案
    \`\`\`
    };                  // pos-1
    /*improve modify*/
    function B(){      // pos-2
        /*something block*/   // pos-3
    \`\`\`
    由于 pos-1, pos-2, pos-3 处相关内容无修改，保持原样全部在修正结果中输出
4. **答案中残缺的函数、类、条件、循环的代码块, 但结合 area_around_code_to_edit 中的内容是完整的，在修正答案不用补全，应保持原样输出**
    输入
    \`\`\`
    <|area_around_code_to_edit|>
        /*something block*/
    <|code_to_edit|>
    class A{                        // pos-1
        /*something block*/
        function B(){               // pos-2
            /*something block*/
    <|/code_to_edit|>
            /*something block*/   // pos-3
        };                          // pos-4
    };                              // pos-5
    <|/area_around_code_to_edit|>
    \`\`\`
    得到答案
    \`\`\`
    class A{                        // pos-1
        /*modify block*/
        function B(){               // pos-2
            /*modify block*/
    \`\`\`
    修正后输出答案
    \`\`\`
    class A{                        // pos-1
        /*improve modify*/
        function B(){               // pos-2
            /*improve modify*/
    \`\`\`
    由于 pos-1 与 area_around_code_to_edit 中的 pos-3,pos-4 是完整的, pos-2 与 area_around_code_to_edit 中的 pos-5 是完整的，因此不要重复输出 pos-3, pos-4, pos-5 中的内容
5. 返回格式维持不变，不要添加额外的换行符

${extra_prompt ? "额外要求\n" + extra_prompt : ""}
`)
                }
            )
        }

        logContext.setPrompt(messages);
        telemetryBuilder.setPrompt(messages);

        /* ... */
    }
```

- 文件： `src\extension\xtab\node\xtabProvider.ts`
- 类：`XtabProvider`
- 修改: 增加 `github.copilot.hackModels.next.remove_code_mark` 配置，控制在 `xtabPromptOptions.ResponseFormat.EditWindowOnly` 格式下，是否移除 `markdown` 标记

```ts
private async *streamEdits(
    request: StatelessNextEditRequest,
    endpoint: IChatEndpoint,
    messages: Raw.ChatMessage[],
    editWindow: OffsetRange,
    editWindowLines: string[],
    cursorOriginalLinesOffset: number,
    cursorLineOffset: number, // cursor offset within the line it's in; 1-based
    editWindowLineRange: OffsetRange,
    promptPieces: PromptPieces,
    prediction: Prediction | undefined,
    opts: {
        responseFormat: xtabPromptOptions.ResponseFormat;
        shouldRemoveCursorTagFromResponse: boolean;
        retryState: RetryState.t;
    },
    delaySession: DelaySession,
    parentTracer: ILogger,
    telemetryBuilder: StatelessNextEditTelemetryBuilder,
    logContext: InlineEditRequestLogContext,
    cancellationToken: CancellationToken,
): EditStreaming {

   /* ... */

    if (opts.responseFormat === xtabPromptOptions.ResponseFormat.EditWindowOnly) {
        // NOTE - 删除 markdown 的标记
        const removeCodeMark = workspace.getConfiguration("github.copilot.hackModels.next").get("remove_code_mark", true);
        if (removeCodeMark) {
            cleanedLinesStream = linesWithBackticksRemoved(linesStream);
        } else {
            cleanedLinesStream = linesStream;
        }
    } else if (opts.responseFormat === xtabPromptOptions.ResponseFormat.CustomDiffPatch) {
        return yield* XtabCustomDiffPatchResponseHandler.handleResponse(
            linesStream,
            request.documentBeforeEdits,
            editWindow,
        );
    } 

    /* ... */
}
```

## 行内补全

- 文档：`src\extension\completions-core\vscode-node\lib\src\openai\openai.ts`
- 修改函数

```ts
export function convertToAPIChoice(
    accessor: ServicesAccessor,
    completionText: string,
    jsonData: APIJsonData,
    choiceIndex: number,
    requestId: RequestId,
    blockFinished: boolean,
    telemetryData: TelemetryWithExp
): APIChoice {
    // NOTE - 需要注释掉，不然会崩溃
    // logEngineCompletion(accessor, completionText, jsonData, requestId, choiceIndex);

    // NOTE: It's possible that the completion text we care about is not exactly jsonData.text but a prefix,
    // so we pass it down directly.
    return {
        // NOTE: This does not contain stop tokens necessarily
        completionText: completionText,
        meanLogProb: calculateMeanLogProb(accessor, jsonData),
        meanAlternativeLogProb: calculateMeanAlternativeLogProb(accessor, jsonData),
        choiceIndex: choiceIndex,
        requestId: requestId,
        blockFinished: blockFinished,
        tokens: jsonData.tokens,
        numTokens: jsonData.tokens.length,
        telemetryData: telemetryData,
        copilotAnnotations: jsonData.copilot_annotations,
        clientCompletionId: generateUuid(),
        finishReason: jsonData.finish_reason,
    };
}
```

- 文档: `src\extension\completions-core\vscode-node\lib\src\openai\fetch.ts`
- 修改
  1. 实现新的 `fetchWithInstrumentation` 请求函数
  2. 请求可通过 `interval` 控制请求时间间隔
  3. 使用 `github.copilot.hackModels.inline` 配置替换请求参数

```ts

// Rate-limiting / spacing of outgoing requests: simple module-level timer
let lastRequestTime = 0;
let lastTimeoutId: ReturnType<typeof setTimeout> | null = null;

async function fetchWithInstrumentation(
    accessor: ServicesAccessor,
    prompt: Prompt,
    engineModelId: string,
    endpoint: string,
    ourRequestId: string,
    request: Record<string, unknown>,
    copilotToken: CopilotToken,
    uiKind: CopilotUiKind,
    telemetryExp: TelemetryWithExp,
    cancel?: ICancellationToken,
    headers?: CompletionHeaders
): Promise<Response> {
    const instantiationService = accessor.get(IInstantiationService);
    const logTarget = accessor.get(ICompletionsLogTargetService);
    const statusReporter = accessor.get(ICompletionsStatusReporter);
    // const uri = instantiationService.invokeFunction(getProxyEngineUrl, copilotToken, engineModelId, endpoint);

    const telemetryData = telemetryExp.extendedBy(
        {
            endpoint: endpoint,
            engineName: engineModelId,
            uiKind: uiKind,
        },
        telemetrizePromptLength(prompt)
    );

    // Skip prompt info (PII)
    sanitizeRequestOptionTelemetry(request, telemetryData, ['prompt', 'suffix'], ['context']);

    const req = request as Partial<CompletionRequest>;

    const inline_config = workspace.getConfiguration("github.copilot.hackModels.inline");

    let uri = inline_config.get("baseUrl", "https://steam/v1") as string;
    const mode = inline_config.get("mode", "chat") as string;
    const token = inline_config.get("apiKey", "xxx");
    const stops = inline_config.get("stop", []) as string[];
    const interval = inline_config.get("capabilities.limits.delay", 200);

    if (req.stop) {
        req.stop.push(...stops);
    } else {
        req.stop = stops;
    }
    req.model = inline_config.get("model", "xxx");

    if (mode === "code") {
        uri += "/completions";
        delete req.code_annotations;
        delete req.suffix;
        delete req.extra;
    } else {
        uri += "/chat/completions";

        // Ensure req.extra is always defined
        if (!req.extra) {
            req.extra = {};
        }
        const content = req.messages && req.messages.length > 0 ? req.messages[0].content : "";

        // 被补全行的前缀
        let linePrefix = '';
        if (req.prompt) {
            for (let i = req.prompt.length - 1; i >= 0; i--) {
                if (req.prompt[i] === '\n') {
                    break;
                }
                linePrefix = req.prompt[i] + linePrefix;
            }
        }
        let prefix = '';
        if (req.prompt) {
            prefix = req.prompt.substring(0, req.prompt.length - linePrefix.length);
        }
        let suffix = '';
        if (req.suffix) {
            suffix = req.suffix;
        }

        req.messages = [
            {
                role: "system",
                content: `你是一名行内补全助手, 需要分析用户正在编写内容的上下文, 在光标后添加建议补全内容。`
            },
            {
                role: "user",
                content: `
    /no_think

    在正在编辑的文档中，开发者的光标所处位置由 <|cursor|> 所标记，且通过光标 <|cursor|> 可将文档划分为上文部分与下文部分。你需要分析文档上文、文档下文以及参考内容，然后输出应当添加到光标 <|cursor|> 位置的补全建议内容。此外，在语义上，输出结果的起始内容不要与 <|line_prefix|> <|/line_prefix|> 之间标记的编辑行前缀内容重复，且输出结果要与文档内容的现有格式保持一致。详细补全执行细节参考示例。

    # 示例

    案例文档如下

    \`\`\`
    # a 非 0 , 则加 1; 否则, 返回 a
    func(int a):
    <|line_prefix|>    if_num_check(<|/line_prefix|><|cursor|>
        return a + 1;
    \`\`\`

    输出结果注意点
    1. **在语义上，输出结果的起始内容不要与 line_prefix 标记的内容重复**。案例中的 line_prefix 为 \`    if_num_check(\`, 因此返回结果若以 \`    if_num_check(\`, \`if_num_check(\`, \`(\` 等字符串起始，在语义上便和 line_prefix 的内容重复
    2. **不要重复输出上下文中已经有内容**。案例中的上文
        \`\`\`
        # a 非 0 , 则加 1; 否则, 返回 a
        func(int a):
            if_num_check(
        \`\`\`
        与下文
        \`\`\`
            return a + 1;
        \`\`\`
        中的内容不要输出
    3. **输出结果要与原内容文本格式保持一致**。案例中文档的上文
        \`\`\`
        # a 非 0 , 则加 1; 否则, 返回 a
        func(int a):
            if_num_check(
        \`\`\`
        中 \`        if_num_check(\` 存在缩进，因此，输出结果补全 if_num_check 的判断条件后, if_num_check 成立的子代码块中的每行代码也要缩进 \`        \` 这么多个空格
    4. 若被编辑的是代码，返回结果${req.code_annotations ? "需要" : "不需要"}包含注释

    ${extra_prompt ? "额外要求\n" + extra_prompt : ""}

    因此，最终输出结果为

    \`\`\`
    a != 0){
            return a;
        }
    \`\`\`


    # 文档内容

    参考内容：

    \`\`\`
    ${context}
    \`\`\`

    开发者正在编辑的文档：

    \`\`\`${req.extra.language ?? "txt"}
    ${prefix}<|line_prefix|>${linePrefix}<|/line_prefix|><|cursor|>
    ${suffix}
    \`\`\`
    `
            }
        ]
    };

    // The request ID we are passed in is sent in the request to the proxy, and included in our pre-request telemetry.
    // We hope (but do not rely on) that the model will use the same ID in the response, allowing us to correlate
    // the request and response.
    telemetryData.properties['headerRequestId'] = ourRequestId;

    instantiationService.invokeFunction(telemetry, 'request.sent', telemetryData);

    const requestStart = now();
    const intent = uiKindToIntent(uiKind);

    // Wrap the Promise with success/error callbacks so we can log/measure it.
    // Schedule the actual network call to enforce a minimum interval between requests.
    const nowTs = Date.now();
    const timeSinceLastRequest = nowTs - lastRequestTime;
    const waitTime = Math.max(0, interval - timeSinceLastRequest);

    logger.debug(logTarget, `Delaying request ${ourRequestId} for ${waitTime}ms to respect request interval`);

    const scheduled = new Promise<Response>((resolve, reject) => {
        const executeRequest = () => {
            return instantiationService.invokeFunction(postRequest, uri, token, intent, ourRequestId, request, cancel, headers)
                .then(response => {
                    // This ID is hopefully the one the same as ourRequestId, but it is not guaranteed.
                    // If they are different then we will override the original one we set in telemetryData above.
                    const modelRequestId = getRequestId(response.headers);
                    telemetryData.extendWithRequestId(modelRequestId);

                    // TODO: Add response length (requires parsing)
                    const totalTimeMs = now() - requestStart;
                    telemetryData.measurements.totalTimeMs = totalTimeMs;

                    logger.info(
                        logTarget,
                        `Request ${ourRequestId} at <${uri}> finished with ${response.status} status after ${totalTimeMs}ms`
                    );
                    telemetryData.properties.status = String(response.status);
                    logger.debug(logTarget, 'request.response properties', telemetryData.properties);
                    logger.debug(logTarget, 'request.response measurements', telemetryData.measurements);

                    logger.debug(logTarget, 'prompt:', prompt);

                    instantiationService.invokeFunction(telemetry, 'request.response', telemetryData);

                    return response;
                })
                .catch((error: unknown) => {
                    if (isAbortError(error)) {
                        // If we cancelled a network request, we want to log a `request.cancel` instead of `request.error`
                        instantiationService.invokeFunction(telemetry, 'request.cancel', telemetryData);
                        throw error;
                    }
                    statusReporter.setWarning(getKey(error, 'message') ?? '');
                    const warningTelemetry = telemetryData.extendedBy({ error: 'Network exception' });
                    instantiationService.invokeFunction(telemetry, 'request.shownWarning', warningTelemetry);

                    telemetryData.properties.message = String(getKey(error, 'name') ?? '');
                    telemetryData.properties.code = String(getKey(error, 'code') ?? '');
                    telemetryData.properties.errno = String(getKey(error, 'errno') ?? '');
                    telemetryData.properties.type = String(getKey(error, 'type') ?? '');

                    const totalTimeMs = now() - requestStart;
                    telemetryData.measurements.totalTimeMs = totalTimeMs;

                    logger.info(
                        logTarget,
                        `Request ${ourRequestId} at <${uri}> rejected with ${String(error)} after ${totalTimeMs}ms`
                    );
                    logger.debug(logTarget, 'request.error properties', telemetryData.properties);
                    logger.debug(logTarget, 'request.error measurements', telemetryData.measurements);

                    instantiationService.invokeFunction(telemetry, 'request.error', telemetryData);

                    throw error;
                });
        };

        if (lastTimeoutId) {
            clearTimeout(lastTimeoutId);
            lastTimeoutId = null;
        }

        lastTimeoutId = setTimeout(async () => {
            try {
                const resp = await executeRequest();
                resolve(resp);
            } catch (e) {
                reject(e);
            }
            lastRequestTime = Date.now();
            lastTimeoutId = null;
        }, waitTime);
    });

    return scheduled.finally(() => {
        instantiationService.invokeFunction(logEnginePrompt, prompt, telemetryData);
    });
}
```

## 行内补全结果修正


- 位置：`src\extension\completions-core\vscode-node\lib\src\ghostText\ghostText.ts`
- 类：`GhostTextComputer`
- 修改: 对 `choices` 结构进行后处理修正

```ts
private async getGhostTextWithoutAbortHandling(
    completionState: CompletionState,
    ourRequestId: string,
    preIssuedTelemetryDataWithExp: TelemetryWithExp,
    cancellationToken: ICancellationToken | undefined,
    options: Partial<GetGhostTextOptions>,
    logContext: GhostTextLogContext,
    telemetryBuilder: LlmNESTelemetryBuilder,
    parentLogger: ILogger,
): Promise<GhostTextResultWithTelemetry<[CompletionResult[], ResultType]>> {

    /* ........... */
    if (choices === undefined) {
        return {
            type: 'failed',
            reason: 'internal error: choices should be defined after network call',
            telemetryData: mkBasicResultTelemetry(telemetryData),
        };
    }

    const remove_prefix = workspace.getConfiguration("github.copilot.hackModels.inline").get("remove_prefix", false);

    // NOTE - 修正输出
    const formatString = (str: string) => {
        str = str.replace(/\s*<think>[\s\S]*?<\/think>\s*?\n*/g, "")
        str = str.replace(/\s*<think>[\s\S]*?<\/thi[\s\S]*?\n*/g, "");
        str = str.replace(/\s*```[a-zA-Z0-9_\-]*\n?/, "")
        str = str.replace(/```\s*$/, "")
        return str;
    };

    // 被补全行的前缀
    let linePrefix = '';
    if (prefix && remove_prefix) {
        for (let i = prefix.length - 1; i >= 0; i--) {
            if (prefix[i] === '\n') {
                break;
            }
            linePrefix = prefix[i] + linePrefix;
        }
    }

    const [choicesArray, resultType] = choices;

    for (let choice of choicesArray) {
        choice.completionText = formatString(choice.completionText);

        if (remove_prefix) {
            for (let i = Math.min(choice.completionText.length, linePrefix.length); i > 0; i--) {
                const subPrefix = linePrefix.substring(linePrefix.length - i);
                const subCompletion = choice.completionText.substring(0, i);
                if (subCompletion === subPrefix) {
                    choice.completionText = choice.completionText.substring(i);
                    break;
                }
            }
        }
    }

    logger.trace(`Final choices: ${choicesArray.length} from ${resultTypeToString(resultType)}`);

    const postProcessedChoicesArray = choicesArray
        .map(c =>
            this.instantiationService.invokeFunction(postProcessChoiceInContext,
                completionState.textDocument,
                completionState.position,
                c,
                isMoreMultiline,
                this.logger
            )
        )
        .filter(c => c !== undefined);
    logger.trace(`Post-processed to ${postProcessedChoicesArray.length} choices`);

    /* ..... */
}
```


