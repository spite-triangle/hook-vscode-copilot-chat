# 请求

## 响应后处理

- 文件： `src\extension\prompt\node\chatMLFetcher.ts`
- 类：`ChatMLFetcherImpl`
- 修改: 增加 `FinishedCompletionReason.ClientDone` 完成标记

    ```ts
    private async processSuccessfulResponse(
        response: ChatResults,
        messages: Raw.ChatMessage[],
        requestBody: IEndpointBody,
        requestId: string,
        maxResponseTokens: number,
        promptTokenCount: number,
        timeToFirstToken: number,
        streamRecorder: FetchStreamRecorder,
        baseTelemetry: TelemetryData,
        chatEndpointInfo: IChatEndpoint,
        userInitiatedRequest: boolean | undefined,
        fetcher: FetcherId | undefined,
        bytesReceived: number | undefined,
    ): Promise<ChatResponses | ChatFetchRetriableError<string[]>> {

        const completions: ChatCompletion[] = [];

        for await (const chatCompletion of response.chatCompletions) {
            Telemetry.sendSuccessTelemetry(
                this._telemetryService,
                {
                    chatCompletion,
                    baseTelemetry,
                    userInitiatedRequest,
                    chatEndpointInfo,
                    requestBody,
                    maxResponseTokens,
                    promptTokenCount,
                    timeToFirstToken,
                    timeToFirstTokenEmitted: (baseTelemetry && streamRecorder.firstTokenEmittedTime) ? streamRecorder.firstTokenEmittedTime - baseTelemetry.issuedTime : -1,
                    hasImageMessages: this.filterImageMessages(messages),
                    fetcher,
                    bytesReceived,
                }
            );

            if (!this.isRepetitive(chatCompletion, baseTelemetry?.properties)) {
                completions.push(chatCompletion);
            }
        }

        // NOTE - 增加 FinishedCompletionReason.ClientDone 完成标记
        const successFinishReasons = new Set([FinishedCompletionReason.Stop, FinishedCompletionReason.ClientDone, FinishedCompletionReason.ClientTrimmed, FinishedCompletionReason.FunctionCall, FinishedCompletionReason.ToolCalls]);
        const successfulCompletions = completions.filter(c => successFinishReasons.has(c.finishReason));
        if (successfulCompletions.length >= 1) {
            return {
                type: ChatFetchResponseType.Success,
                resolvedModel: successfulCompletions[0].model,
                usage: successfulCompletions.length === 1 ? successfulCompletions[0].usage : undefined,
                value: successfulCompletions.map(c => getTextPart(c.message.content)),
                requestId,
                serverRequestId: successfulCompletions[0].requestId.headerRequestId,
            };
        }

        /* .... */
    }
    ```

## 通用请求

- 文件：`src\platform\networking\common\networking.ts`
- 修改函数: `function networkRequest`
- 修改： 自定义模型请求方式

    ```ts
    function networkRequest(
        fetcher: IFetcher,
        telemetryService: ITelemetryService,
        capiClientService: ICAPIClientService,
        requestType: 'GET' | 'POST',
        endpointOrUrl: IEndpoint | string | RequestMetadata,
        secretKey: string,
        intent: string,
        requestId: string,
        body?: IEndpointBody,
        additionalHeaders?: Record<string, string>,
        cancelToken?: CancellationToken,
        useFetcher?: FetcherId,
        canRetryOnce: boolean = true,
        location?: ChatLocation,
    ): Promise<Response> {

        /* .... */

        let url: string | undefined = undefined;
        if (typeof endpoint.urlOrRequestMetadata !== 'string'
            && endpoint.urlOrRequestMetadata.baseUrl !== undefined
            && endpoint.urlOrRequestMetadata.apiKey !== undefined) {
            secretKey = endpoint.urlOrRequestMetadata.apiKey;
            url = endpoint.urlOrRequestMetadata.baseUrl;
            if (body) {
                body.model = endpoint.urlOrRequestMetadata.model;
            }

            switch (endpoint.urlOrRequestMetadata.type) {
                case RequestType.Models: url += "/models"; break;
                case RequestType.CAPIEmbeddings: url += "/embeddings"; break;
                case RequestType.ChatCompletions: url += "/chat/completions"; break;
                case RequestType.ChatResponses: url += "/responses"; break;
                case RequestType.ChatMessages: url += "/v1/messages"; break;
                default:
                    url = undefined;
            }
        } else if (typeof endpoint.urlOrRequestMetadata !== 'string'
            && (endpoint.urlOrRequestMetadata.type == RequestType.ProxyCompletions
                || endpoint.urlOrRequestMetadata.type == RequestType.ProxyChatCompletions
            )
        ) {
            const next_config = workspace.getConfiguration("github.copilot.hackModels.next");
            url = next_config.get("baseUrl", "https://api.vectorengine.ai/v1") + "/chat/completions";
            secretKey = next_config.get("apiKey", "xxx")
            if (body) {
                body.model = next_config.get("model", "gpt-4o");
            }
        }

        const headers: ReqHeaders = {
            Authorization: `Bearer ${secretKey}`,
            'X-Request-Id': requestId,
            'X-Interaction-Type': intent,
            'OpenAI-Intent': intent, // Tells CAPI who flighted this request. Helps find buggy features
            'X-GitHub-Api-Version': '2025-05-01',
            ...additionalHeaders,
            ...(endpoint.getExtraHeaders ? endpoint.getExtraHeaders(location) : {}),
        };

        if (endpoint.interceptBody) {
            endpoint.interceptBody(body);
        }


        const endpointFetchOptions = endpoint.getEndpointFetchOptions?.();
        const request: FetchOptions = {
            method: requestType,
            headers: headers,
            json: body,
            timeout: requestTimeoutMs,
            useFetcher,
            suppressIntegrationId: endpointFetchOptions?.suppressIntegrationId
        };

        if (cancelToken) {
            const abort = fetcher.makeAbortController();
            cancelToken.onCancellationRequested(() => {
                // abort the request when the token is canceled
                telemetryService.sendGHTelemetryEvent('networking.cancelRequest', {
                    headerRequestId: requestId,
                });
                abort.abort();
            });
            // pass the controller abort signal to the request
            request.signal = abort.signal;
        }
        if (typeof endpoint.urlOrRequestMetadata === 'string') {
            const requestPromise = fetcher.fetch(endpoint.urlOrRequestMetadata, request).catch(reason => {
                if (canRetryOnce && canRetryOnceNetworkError(reason)) {
                    // disconnect and retry the request once if the connection was reset
                    return fetcher.disconnectAll().then(() => {
                        return fetcher.fetch(endpoint.urlOrRequestMetadata as string, request);
                    });
                } else if (fetcher.isAbortError(reason)) {
                    throw new CancellationError();
                } else {
                    throw reason;
                }
            });
            return requestPromise;
        } else if (url) {

            const requestPromise = fetcher.fetch(url, request)
                .then(resp => {
                    return resp;
                })
                .catch(reason => {
                    if (canRetryOnce && canRetryOnceNetworkError(reason)) {
                        // disconnect and retry the request once if the connection was reset
                        return fetcher.disconnectAll().then(() => {
                            return fetcher.fetch(url, request);
                        });
                    } else if (fetcher.isAbortError(reason)) {
                        throw new CancellationError();
                    } else {
                        throw reason;
                    }
                });
            return requestPromise;
        } else {
            return capiClientService.makeRequest(request, endpoint.urlOrRequestMetadata as RequestMetadata);
        }
    }

    ```

